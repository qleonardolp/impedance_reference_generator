// Copyright (c) 2025, qleonardolp
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#ifndef IMPEDANCE_REFERENCE_GENERATOR__KINEMATIC_REFERENCE_HPP_
#define IMPEDANCE_REFERENCE_GENERATOR__KINEMATIC_REFERENCE_HPP_

#include <cmath>
#include <chrono>
#include <map>
#include <memory>
#include <string>
#include <vector>

#include <kinematic_pose_msgs/msg/kinematic_pose.hpp>
#include <std_msgs/msg/float64.hpp>
#include <lifecycle_msgs/msg/state.hpp>
#include <rclcpp/qos.hpp>
#include <rclcpp/rclcpp.hpp>
#include <rclcpp_lifecycle/lifecycle_node.hpp>
#include <rclcpp_lifecycle/state.hpp>

// auto-generated by generate_parameter_library
#include <impedance_reference_generator/kinematic_reference_parameters.hpp>

namespace kinematic_reference
{
enum SignalType
{
  kStep,
  kSmoothStep,
  kSineWave,
  kStepUpDown,
};

std::map<std::string, uint8_t> TypeMap = {
  {std::string("step"), SignalType::kStep},
  {std::string("smooth-step"), SignalType::kSmoothStep},
  {std::string("sinewave"), SignalType::kSineWave},
  {std::string("step-up-down"), SignalType::kStepUpDown}
};

std::map<char, std::size_t> AxisMap = {
  {'x', 0}, {'y', 1}, {'z', 2}, {'r', 3}, {'p', 4}, {'w', 5}
};

const uint8_t kCartesianSpaceDim = 6;
const double kTimeOffset = 2.0;  // seconds
const double kSmoothStepEnd = kTimeOffset + 0.22;
const double kSmoothStepSlope = 77.0;

using KinematicPose = kinematic_pose_msgs::msg::KinematicPose;
using CallbackReturn = rclcpp_lifecycle::node_interfaces::LifecycleNodeInterface::CallbackReturn;

/**
 * @brief Lifecycle Node with a simple publisher and configurable reference signal
 * through the node parameters
 */
class KinematicReference : public rclcpp_lifecycle::LifecycleNode
{
public:
  explicit KinematicReference(const std::string & node_name, bool intra_process_comms = false);

  CallbackReturn on_configure(const rclcpp_lifecycle::State & previous_state) override;

  CallbackReturn on_cleanup(const rclcpp_lifecycle::State & previous_state) override;

  CallbackReturn on_activate(const rclcpp_lifecycle::State & previous_state) override;

  CallbackReturn on_deactivate(const rclcpp_lifecycle::State & previous_state) override;

  CallbackReturn on_shutdown(const rclcpp_lifecycle::State & previous_state) override;


  /**
   * @brief Compute the mechanical work (power) required by
   * a mass-spring-damper (MSD) when a step input is set for the
   * equilibrium point, i.e. the desired position. Desired velocity
   * and acceleration are zero.
   */
  void step_power(const double time);

  /**
   * @brief Approximate a (Heaviside) step function by
   * the Logistic function, which is differentiable.
   *
   * The Logistic function is f(x) = 1 / (1 + exp(-x))
   */
  double logistic_function(const double arg);

  /**
   * @brief Logistic function first order derivative
   */
  double logistic_velocity(const double arg);

  /**
   * @brief Logistic function second order derivative
   */
  double logistic_acceleration(const double arg);

  /**
   * @brief Reference signal publisher callback
   */
  void publisher_callback();

private:
  std::shared_ptr<rclcpp::TimerBase> timer_;
  std::shared_ptr<rclcpp::Publisher<KinematicPose>> publisher_;
  KinematicPose message_;

  rclcpp::Time start_time_;
  double ellapsed_time_{0};
  double angular_freq_{1};

  std::vector<double> accelerations_;
  std::vector<double> velocities_;
  std::vector<double> positions_;
  std::size_t axis_;
  int signal_type_;

  std::shared_ptr<ParamListener> param_listener_;
  Params params_;

  std::shared_ptr<rclcpp::Publisher<std_msgs::msg::Float64>> power_publisher_;
  std_msgs::msg::Float64 power_;

  double mass_;
  double spring_;
  double damper_;

  // Flag to indicate if is critically damped
  bool is_critically_damped_{false};
  // Undamped natural frequency
  double wn_;
  // Damping factor
  double zeta_;
  // Damped frequency
  double wd_;
  // Sigma
  double sigma_;
  // Beta
  double beta_;
  // Chi
  double chi_;
};

}  // namespace kinematic_reference

#endif  // IMPEDANCE_REFERENCE_GENERATOR__KINEMATIC_REFERENCE_HPP_
